var documenterSearchIndex = {"docs":
[{"location":"#MomentOpt.jl-1","page":"Getting Started","title":"MomentOpt.jl","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Simulated Method of Moments for Julia","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"A package providing supporting infrastructure and algorithms to perform Simulated Method of Moments.","category":"page"},{"location":"#Features-1","page":"Getting Started","title":"Features","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Supply your own objective function to be optimized\nOptimization can be carried out in parallel\nDiagnostic plots illustrating the proposal distribution as well as markov chain statistics\nIncludes a parellel tempering likelihood-free optimizer using MCMC technology and a coordinate descent optimizer.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"For some example usage see the Examples page.","category":"page"},{"location":"#Manual-Outline-1","page":"Getting Started","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Pages = [\"index.md\",\"eval.md\",\"slices.md\",\"algo.md\",\"examples.md\"]","category":"page"},{"location":"#MProb:-Minimisation/Maximisation-Problems-1","page":"Getting Started","title":"MProb: Minimisation/Maximisation Problems","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"A core object of this library is the MProb type, specifying an optimisation problem.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Modules = [MomentOpt]\nPages = [\"mprob.jl\"]","category":"page"},{"location":"#MomentOpt.MProb","page":"Getting Started","title":"MomentOpt.MProb","text":"Minimisation Problem: MProb\n\nA moment minimsation problem is defined by an objective function that depends on a vector of unknown parameters params_to_sample, and a set of datamoments moments. The key idea here is the one of simulated method of moments, where we use params_to_sample to simulate a model, some moments of which will be compared to moments from the data.\n\nFields:\n\ninitial_value: initial parameter value as a dict\nparams_to_sample: OrderedDict with lower and upper bounds\nobjfunc: objective function\nobjfunc_opts: options passed to the objective function, e.g. printlevel\nmoments: a dictionary of data moments to track\n\nExample:\n\npb    = Dict(p1\" => [0.2,-2,2] , \"p2\" => [-0.2,-2,2] )\nmoms  = DataFrame(name=[\"mu2\",\"mu1\"],value=[0.0,0.0],weight=rand(2))\nm     = MProb() \naddSampledParam!(m,pb) \naddMoment!(m,moms) \nMomentOpt.addEvalFunc!(m,MomentOpt.objfunc_norm)\n\n\n\n\n\n","category":"type"},{"location":"#MomentOpt.addMoment!-Tuple{MProb,String,Any,Any}","page":"Getting Started","title":"MomentOpt.addMoment!","text":"addMoment!(m::MProb,name::String,value,weight)\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addMoment!-Tuple{MProb,String,Any}","page":"Getting Started","title":"MomentOpt.addMoment!","text":"addMoment!(m::MProb,name::String,value)\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addMoment!-Tuple{MProb,Symbol,Any,Any}","page":"Getting Started","title":"MomentOpt.addMoment!","text":"addMoment!(m::MProb,name::Symbol,value,weight)\n\nAdd Moments to an MProb. Adds a single moment to the mprob.\n\nname: the name of the moment as a Symbol value: value of the moment weight: weight in the objective function\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addMoment!-Tuple{MProb,Symbol,Any}","page":"Getting Started","title":"MomentOpt.addMoment!","text":"addMoment!(m::MProb,name::Symbol,value)\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addParam!-Tuple{MProb,String,Any}","page":"Getting Started","title":"MomentOpt.addParam!","text":"Add initial parameter values to an MProb minimisation problem.\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addParam!-Tuple{MProb,Union{Dict, OrderedDict}}","page":"Getting Started","title":"MomentOpt.addParam!","text":"Add initial parameter values to an MProb minimisation problem.\n\nArguments:\n\np: A Dict with (String,Number) pairs\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.addSampledParam!","page":"Getting Started","title":"MomentOpt.addSampledParam!","text":"Add parameters to be sampled to an MProb.\n\nd: a Dict with a triple (init,lb,ub) as value for each key.\n\n\n\n\n\n","category":"function"},{"location":"#MomentOpt.addSampledParam!-Tuple{MProb,Any,Any,Any,Any}","page":"Getting Started","title":"MomentOpt.addSampledParam!","text":"Add parameters to be sampled to an MProb.\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.evaluateObjective-Tuple{MProb,Any}","page":"Getting Started","title":"MomentOpt.evaluateObjective","text":"evaluateObjective(m::MProb,ev::Eval)\n\nEvaluate the objective function of an MProb at a given Eval.\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.evaluateObjective-Tuple{MProb,Union{Dict, OrderedDict}}","page":"Getting Started","title":"MomentOpt.evaluateObjective","text":"evaluateObjective(m::MProb,p::Union{Dict,OrderedDict};noseed=false)\n\nEvaluate the objective function of an MProb at a given parameter vector p.  Set noseed to true if you want to generate new random draws for shocks in the objective function (necessary for estimation of standard errors in get_stdErrors, for example)\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.mapto_01-Tuple{OrderedCollections.OrderedDict,Array{Float64,1},Array{Float64,1}}","page":"Getting Started","title":"MomentOpt.mapto_01","text":"map param to [0,1]\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.mapto_ab-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Getting Started","title":"MomentOpt.mapto_ab","text":"map param from [0,1] to [a,b]\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.ms_names-Tuple{MProb}","page":"Getting Started","title":"MomentOpt.ms_names","text":"Get the name of moments\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.ps2s_names-Tuple{MProb}","page":"Getting Started","title":"MomentOpt.ps2s_names","text":"Get sampled parameter names from the MProb\n\n\n\n\n\n","category":"method"},{"location":"#MomentOpt.ps_names-Tuple{MProb}","page":"Getting Started","title":"MomentOpt.ps_names","text":"Get all parameter names from the MProb\n\n\n\n\n\n","category":"method"},{"location":"eval/#eval_type-1","page":"Eval Object","title":"Eval Type","text":"","category":"section"},{"location":"eval/#","page":"Eval Object","title":"Eval Object","text":"This is a datatype to track function evaluations:","category":"page"},{"location":"eval/#","page":"Eval Object","title":"Eval Object","text":"Modules = [MomentOpt]\nPages = [\"Eval.jl\"]","category":"page"},{"location":"eval/#MomentOpt.Eval","page":"Eval Object","title":"MomentOpt.Eval","text":"Eval type for managing function evaluations\n\nfields\n\nvalue: current function value\ntime: timing of evaluation\nparams: OrderedDict of parameters\nsimMoments: OrderedDict of moments generated by model\ndataMoments: OrderedDict of data moments\ndataMomentsW: OrderedDict of weights for data moments\nstatus: Int error status\nprob: probability of acceptance\naccepted: whether draw was accepted\noptions: Dict of options and other info\n\n\n\n\n\n","category":"type"},{"location":"eval/#MomentOpt.dataMomentd-Tuple{Eval}","page":"Eval Object","title":"MomentOpt.dataMomentd","text":"dataMomentd(ev::Eval)\n\nObtain all data momoents as dict\n\n\n\n\n\n","category":"method"},{"location":"eval/#MomentOpt.check_moments-Tuple{Eval}","page":"Eval Object","title":"MomentOpt.check_moments","text":"check_moments(ev::Eval)\n\nreturns all data and simluated moments of a single Eval as a dataframe.\n\n\n\n\n\n","category":"method"},{"location":"eval/#MomentOpt.dataMomentWd-Tuple{Eval}","page":"Eval Object","title":"MomentOpt.dataMomentWd","text":"Obtain all moment weights as dict\n\n\n\n\n\n","category":"method"},{"location":"slices/#slices-1","page":"Slices","title":"Slices from a MProb","text":"","category":"section"},{"location":"slices/#","page":"Slices","title":"Slices","text":"Modules = [MomentOpt]\nPages = [\"slices.jl\"]","category":"page"},{"location":"slices/#MomentOpt.doSlices","page":"Slices","title":"MomentOpt.doSlices","text":"doSlices(m::MProb,npoints::Int,parallel=false)\n\nComputes Slices of an MProb\n\n\n\n\n\n","category":"function"},{"location":"slices/#MomentOpt.Slice","page":"Slices","title":"MomentOpt.Slice","text":"Slice\n\nA slice in dimension j of a function f in mathbbR^N is defined as f(p1pjpN), where p is the initial parameter vector and p[j] = range(lower[j], stop = upper[j], length = npoints), where lower[j],upper[j] are the bounds of the parameter space in dimension j.\n\nFields\n\nres: Dict of resulting slices. For each parameter p_j there is a Dict with as many entries as npoints chosen in doSlices\np0: Initial parameter vector dict\nm0: data moments dict\n\nExamples\n\njulia> using MOpt\njulia> m = MProb()\njulia> p = OrderedDict(:p1=>1.1,:p2=>pi)\njulia> m = OrderedDict(:m1=>rand(),:m2=>e)\njulia> Slice(p,m)\n\n\n\n\n\n\n","category":"type"},{"location":"slices/#MomentOpt.optSlices-Tuple{MProb,Int64}","page":"Slices","title":"MomentOpt.optSlices","text":"optSlices(m::MProb,npoints::Int,parallel=false)\n\nComputes Slices of an MProb and keeps the best value from each slice. This implements a naive form of cyclic coordinate descent in that it optimizes wrt to one direction at a time, keeping the best value. It's naive because it does a grid search in that direction (and disregards any gradient information). The grid size shrinks, however, at a rate update.\n\n\n\n\n\n","category":"method"},{"location":"algo/#algos-1","page":"Moment Algorithms","title":"Moment Optimization Algorithms","text":"","category":"section"},{"location":"algo/#","page":"Moment Algorithms","title":"Moment Algorithms","text":"Modules = [MomentOpt]\nPages = [\"AlgoAbstract.jl\"]","category":"page"},{"location":"algo/#MomentOpt.MAlgo","page":"Moment Algorithms","title":"MomentOpt.MAlgo","text":"Moment Minisation Algorithm Type\n\nThis abstract type nests all MProb algorithms, for example MomentOpt.AlgoBGP\n\n\n\n\n\n","category":"type"},{"location":"algo/#MomentOpt.readMalgo-Tuple{AbstractString}","page":"Moment Algorithms","title":"MomentOpt.readMalgo","text":"readMalgo(filename::AbstractString)\n\nLoad MAlgo from disk\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.runMOpt!-Tuple{MAlgo}","page":"Moment Algorithms","title":"MomentOpt.runMOpt!","text":"runMOpt!( algo::MAlgo )\n\nFunction to start estimation of an MAlgo.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.save-Tuple{MAlgo,AbstractString}","page":"Moment Algorithms","title":"MomentOpt.save","text":"save(algo::MAlgoBGP, filename::AbstractString)\n\nSave MAlgo to disk using JLD2\n\n\n\n\n\n","category":"method"},{"location":"algo/#","page":"Moment Algorithms","title":"Moment Algorithms","text":"A particular implementation of such an algorithm is the BGP algorithm:","category":"page"},{"location":"algo/#BGP-Algorithm-1","page":"Moment Algorithms","title":"BGP Algorithm","text":"","category":"section"},{"location":"algo/#","page":"Moment Algorithms","title":"Moment Algorithms","text":"Modules = [MomentOpt]\nPages = [\"AlgoBGP.jl\"]","category":"page"},{"location":"algo/#MomentOpt.MAlgoBGP","page":"Moment Algorithms","title":"MomentOpt.MAlgoBGP","text":"MAlgoBGP: BGP MCMC Algorithm\n\nThis implements the BGP MCMC Algorithm *Likelihood-Free Parallel Tempering by Baragatti, Grimaud and Pommeret (BGP):\n\nApproximate Bayesian Computational (ABC) methods (or likelihood-free methods) have appeared in the past fifteen years as useful methods to perform Bayesian analyses when the likelihood is analytically or computationally intractable. Several ABC methods have been proposed: Monte Carlo Markov BGPChains (MCMC) methods have been developped by Marjoramet al. (2003) and by Bortotet al. (2007) for instance, and sequential methods have been proposed among others by Sissonet al. (2007), Beaumont et al. (2009) and Del Moral et al. (2009). Until now, while ABC-MCMC methods remain the reference, sequential ABC methods have appeared to outperforms them (see for example McKinley et al. (2009) or Sisson et al. (2007)). In this paper a new algorithm combining population-based MCMC methods with ABC requirements is proposed, using an analogy with the Parallel Tempering algorithm (Geyer, 1991). Performances are compared with existing ABC algorithms on simulations and on a real example.\n\nFields\n\nm: MProb\nopts: a Dict of options\ni: current iteration\nchains: An array of BGPChain\nanim: Plots.Animation\ndist_fun: function to measure distance between one evaluation and the next.\n\n\n\n\n\n","category":"type"},{"location":"algo/#MomentOpt.CI-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.CI","text":"CI(c::BGPChain;level=0.95)\n\nConfidence interval on parameters\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.extendBGPChain!-Tuple{MomentOpt.BGPChain,MAlgoBGP,Int64}","page":"Moment Algorithms","title":"MomentOpt.extendBGPChain!","text":"extendBGPChain!(chain::BGPChain, algo::MAlgoBGP, extraIter::Int64)\n\nStarting from an existing AlgoBGP, allow for additional iterations by extending a specific chain. This function is used to restart a previous estimation run via restartMOpt!\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.restartMOpt!-Tuple{MAlgoBGP,Int64}","page":"Moment Algorithms","title":"MomentOpt.restartMOpt!","text":"restartMOpt!(algo::MAlgoBGP, extraIter::Int64)\n\nStarting from an existing AlgoBGP, restart the optimization from where it stopped. Add extraIter additional steps to the optimization process.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.summary-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.summary","text":"summary(c::BGPChain)\n\nReturns a summary of the chain. Condensed history\n\n\n\n\n\n","category":"method"},{"location":"algo/#Statistics.mean-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"Statistics.mean","text":"mean(c::BGPChain)\n\nReturns the mean of all parameter values stored on the chain.\n\n\n\n\n\n","category":"method"},{"location":"algo/#Statistics.median-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"Statistics.median","text":"median(c::BGPChain)\n\nReturns the median of all parameter values stored on the chain.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.BGPChain","page":"Moment Algorithms","title":"MomentOpt.BGPChain","text":"BGPChain\n\nMCMC Chain storage for BGP algorithm. This is the main datatype for the implementation of Baragatti, Grimaud and Pommeret (BGP) in Likelihood-free parallel tempring\n\nFields\n\nevals: Array of Evals\nbest_id: index of best eval.value so far\nbest_val: best eval.value so far\ncurr_val : current value\nprobs_acc: vector of probabilities with which to accept current value\nid: Chain identifier\niter: current iteration\naccepted: Array{Bool} of length(evals)\naccept_rate: current acceptance rate\nacc_tuner: Acceptance tuner. acc_tuner > 1 means to be more restrictive: params that yield a worse function value are less likely to get accepted, the higher acc_tuner is.\nexchanged: Array{Int} of length(evals) with index of chain that was exchanged with\nm: MProb\nsigma: Float64 shock variance\nsigma_update_steps:  update sampling vars every sigma_update_steps iterations. setting sigma_update_steps > maxiter means to never update the variances.\nsigma_adjust_by: adjust sampling vars by sigma_adjust_by percent up or down\nsmpl_iters: max number of trials to get a new parameter from MvNormal that lies within support\nmin_improve: minimally required improvement in chain j over chain i for an exchange move j->i to talk place.\nbatches: in the proposal function update the parameter vector in batches. [default: update entire param vector]\n\n\n\n\n\n","category":"type"},{"location":"algo/#MomentOpt.allAccepted-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.allAccepted","text":"allAccepted(c::BGPChain)\n\nGet all accepted Evals from a chain\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.best-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.best","text":"best(c::BGPChain) -> (val,idx)\n\nReturns the smallest value and index stored of the chain.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.computeNextIteration!-Tuple{MAlgoBGP}","page":"Moment Algorithms","title":"MomentOpt.computeNextIteration!","text":"computeNextIteration!( algo::MAlgoBGP )\n\ncomputes new candidate vectors for each BGPChain accepts/rejects that vector on each BGPChain, according to some rule. The evaluation objective functions is performed in parallel, is so desired.\n\nOn each chain c:\ncomputes new parameter vectors\napplies a criterion to accept/reject any new params\nstores the result in BGPChains\nCalls exchangeMoves! to swap chains\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.doAcceptReject!-Tuple{MomentOpt.BGPChain,Eval}","page":"Moment Algorithms","title":"MomentOpt.doAcceptReject!","text":"doAcceptReject!(c::BGPChain,eval_new::Eval)\n\nPerform a Metropolis-Hastings accept-reject operation on the latest Eval and update the sampling variance, if so desired (set via sigma_update_steps in BGPChain constructor.)\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.exchangeMoves!-Tuple{MAlgoBGP}","page":"Moment Algorithms","title":"MomentOpt.exchangeMoves!","text":"exchangeMoves!(algo::MAlgoBGP)\n\nExchange chain i and j with if dist_fun(evi.value,evj.value) is greate than a threshold value c.min_improve. Commonly, this means that we only exchange if j is better by at least c.min_improve.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.history-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.history","text":"history(c::BGPChain)\n\nReturns a DataFrame with a history of the chain.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.mysample-Tuple{Distributions.Distribution{Distributions.Multivariate,S} where S<:Distributions.ValueSupport,Float64,Float64,Int64}","page":"Moment Algorithms","title":"MomentOpt.mysample","text":"mysample(d::Distributions.MultivariateDistribution,lb::Vector{Float64},ub::Vector{Float64},iters::Int)\n\nmysample from distribution d until all poins are in support. This is a crude version of a truncated distribution: It just samples until all draws are within the admissible domain.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.next_eval-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.next_eval","text":"next_eval(c::BGPChain)\n\nComputes the next Eval for chain c:\n\nGet last accepted param \nget a new param via proposal\nevaluateObjective\nAccept or Reject the new value via doAcceptReject!\nStore Eval on chain c.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.proposal-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.proposal","text":"proposal(c::BGPChain)\n\nGaussian Transition Kernel centered on current parameter value. \n\nMap all k parameters into mu in 01^k.\nupdate all parameters by sampling from MvNormal, N(musigma), where sigma is c.sigma until all params are in 01^k\nMap 01^k back to original parameter spaces.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.set_acceptRate!-Tuple{MomentOpt.BGPChain}","page":"Moment Algorithms","title":"MomentOpt.set_acceptRate!","text":"set acceptance rate on chain. considers only iterations where no exchange happened.\n\n\n\n\n\n","category":"method"},{"location":"algo/#MomentOpt.swap_ev_ij!-Tuple{MAlgoBGP,Int64,Int64}","page":"Moment Algorithms","title":"MomentOpt.swap_ev_ij!","text":"replace the current Eval of chain i with the one of chain j\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Estimating-Means-of-a-bivariate-normal-1","page":"Examples","title":"Estimating Means of a bivariate normal","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Let's define a function that returns a Normal distribution with a certain location, and let's call this our model:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"m(p) = mathcalNleft( p_1p_2  I_2 right)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Our aim is to estimate the location of means from data that is simulated from that law with an MCMC chain. (Of course the sample mean would be a perfectly valid estimator.) The twist here is that we will pretend that we don't have access to the entire dataset X_i_i=1^N X_i = (x_i1x_i2), but only a set of summary statistics S - in our case, we'd have two moments of this data, namely mu_j = frac1Nx_ijj=12. Our objective function is the squared distance between mu, and what our model produces instead. That is, we give a parameter vector p to our model m, which in turn produces 2 simulated moments denoted hatmu. Finally, we assess their respective distance.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Again: ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Assume true moments mu.\nrepeatedly create data from m(p) for different p drawn from a space [-3,3] x [-2,2]. For each dataset, compute hatmu_j = frac1Nx_ijj=12.\nCompute distance muhatmu and decide according to BGP algorithm whether to accept or reject current p. ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> using MomentOpt\njulia> pb    = OrderedDict(\"p1\" => [0.2,-3,3] , \"p2\" => [-0.2,-2,2] )\njulia> moms  = DataFrame(name=[\"mu1\",\"mu2\"],value=[-1.0,1.0],weight=ones(2))\njulia> mprob = MProb() \njulia> addSampledParam!(mprob,pb) \njulia> addMoment!(mprob,moms) \njulia> addEvalFunc!(mprob,objfunc_norm)\n\njulia> nchains = 3\n\njulia> opts =Dict(\"N\"=>nchains,\"maxiter\"=> 10,\"maxtemp\"=> 5,\"coverage\"=>0.025,\n \"sigma_update_steps\"=>10, \"sigma_adjust_by\"=>0.01, \"smpl_iters\"=>1000,\n  \"parallel\"=>true, \"min_improve\"=>[0.05 for i in 1:nchains], \"mixprob\"=>0.3, \n  \"acc_tuners\"=>[12.0 for i in 1:nchains], \"animate\"=>false)\n\njulia> MA = MAlgoBGP(mprob,opts)\n\nBGP Algorithm with 3 BGPChains\n============================\n\nAlgorithm\n---------\nCurrent iteration: 0\nNumber of params to estimate: 2\nNumber of moments to match: 2\n\njulia> runMOpt!(MA)\n[ Info: Starting estimation loop.\nProgress: 100%|████████████████████████████████████████| Time: 0:00:04\n┌ Warning: could not find 'filename' in algo.opts\n└ @ MomentOpt ~/.julia/v0.6/MomentOpt/src/mopt/AlgoAbstract.jl:69\n[ Info: Done with estimation after 0.1 minutes\n","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Full list of options is available at the MomentOpt.BGPChain documentation","category":"page"}]
}
